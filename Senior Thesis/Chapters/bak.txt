
\section{Copy-On-Write}

The main operation this paper investigates is copy-on-write (COW), where two processes map a page of their virtual address space to the same physical frame until one of tries to write to the page. The page is marked read-only so that this write causes a page fault, allowing the kernel to handle it. At that point, the page is copied, the writing process changes its mapping to the new page, and only the new page receives the write. This allows processes to share as much memory as possible, reducing memory usage and increasing performance. With superpages, much of this benefit is lost because even a small write forces the entire large region to be copied. Alternatively, a transparent hugepage could be split when a COW occurs to allow only 4KB to be copied at a time, but this gives up the TLB miss savings. Transparent hugepages are not currently split by default for COW.

COW is most commonly used whenever a program forks to create a new process. The child process shares its parent's address space until writes trigger the COW mechanism for each page. This makes the fork operation much faster than it would be if the whole address space was copied, and it reduces memory usage by never duplicating sections of memory that do not change.

Another possible application of COW is in memory checkpointing. It may be useful to take periodic snapshots of the memory of a system, to allow error recovery, backups, or speculative changes. A simple way to accomplish this is to write-protect the entire address space at the start of a checkpoint and use COW to allow the program to continue normal execution while another process writes out the memory to a different location \cite{Sun}.
